b# Hi👋 こちらはPythonのオブジェクト指向を再度勉強するためのリポジトリです。

特にSOLID原則、デザインパターンなどについて対応します。

下記のUdemyを参照

| フォルダ | リンク |
|:-----------|:------------|
| v1       | [Python で身につける オブジェクト指向【SOLID原則+デザインパターンで、オブジェクト指向設計 の基礎を習得！】](https://www.udemy.com/course/python-solid-design-pattern/)  |


## コースの説明による追記 memo

### セクション1
クリーンアーキテクチャも提唱しているロバート・C・マーティン(Bobおじさん)が提唱<br>
オブジェクト指向開発の5つの原則。<br>
5つの原則を守ることで保守しやすいソフトウェアを設計できる<br>
SOLID原則
- S: 単一責任の原則
- O: オープン、クローズドの原則
- L: リフコフの置換原則
- I: インターフェース分離の原則
- D: 依存関係逆転の原則

SOLID原則を学ぶメリット

そもそもオブジェクト指向の3大要素
- クラス(カプセル化)
- 承継
- ポリモーフィズム

実際は3大要素を学んだだけではオブジェクト指向を最大限活用できない<br>
=> 3大要素は構成要素でしかない(英単語だけを知っていても英作文はできない)<br>
=> SOLID原則を理解して3大要素の効果的な使い方を身につける必要がある


### セクション2
- 例外周り
  - Pythonも0で割ると例外エラーになる
  - キャッチする例外は具体的な方が望ましい
    - 全てをキャッチするExceptionに頼るのではなくて、ValueErrorなど具体的に設定する
  - クラスやメソッドの正しい使用を強制するために
    - オブジェクトを作る際のコンストラクタにて、正常値でないとオブジェクトを作れない使用にしておくとよい。
    - 不正な値が渡されたら例外を発生させるようなメソッドをガード節という
- フールプルーフとアクセス制限
  - foolproofとはバカにも耐えられる設計にすることをいう。
    - ユーザーに頼るのではなく、誤った操作をそもそもできないようにして正しい使用を強制させる設計
    - フールプルーフの考えに基づいてクラス内部からのみアクセス可能なプライベートな属性やメソッドを定義できる
    - ただ、Pythonはクラス内部からのみアクセスできるプライペートな属性を定義できない
      - これはPythonの設計自体がフールプルーフを取り入れているわけではなく、制約より自由に重きを置いているから
      - ただ慣例としてメソッドの先頭に_を取り入れることでプライペートなメソッド、属性を表現できる
    - name mangling(名前マングリング)
      - 先頭にアンスコを2つ入れることで置換する方法(アクセスできなくなるわけではなく置換する)
      - _MyClass__PIのように結果としてアクセスはできてしまう
      - 本当の用途は親クラスと子クラスで変数名が衝突するみたいな時に使う(サブクラスで同じ名前の変数を使いたい場合など)
    - @propertyデコレータ
      - 用途1: 属性を読み取り専用(もどき)にして外部に公開
      - 用途2: 値のアクセス前後に処理を挟む
      - setterを定義することで、プライペートな変数を上書きすることができるようになり、その前後に処理を挟めるようになる
- 依存関係
  - 承継とコンポジション
    - 承継は is aのようになる。クラスの承継など
    - コンポジションは has aのようになる。関数内で持っている的な
    - 依存していると依存先の変更の影響を受けやすい。これは承継もコンポジションも同じ
  - 変更しやすいソフトウェアを作るためには
    - なるべく依存関係は少ない方が望ましい
    - 変更されないもの、変更が少ないものに依存するのが望ましい

### セクション3 単一責任の原則
Single Responsibility Principle：SRP<br>
言い換えると凝集度を高める原則とも言える<br>
値を正常値に保つことも責務と言える、コンストラクタで値のチェックはだめ。値オブジェクトを使ってみたいな

- クラスの変更理由は一つだけにすべきである
  - それぞれのクラスの責務は一つだけにするべき
  - ざっくりいうとクラスには一つのメソッドだけにする。的な。(デメリットもあるよ)
  - VideoControllerクラスという抽象的なクラスではなく、VideoUploader, VideoPlayer, CommentPostみたいに分ける。
    - するとどんなクラスかが分かりやすく、変更に強い。変更する箇所が一つだけになる
- クラスだけではなくてメソッドや関数においても言える
  - データの整形 > 処理 > フォーマット化という複数の責務を持つのではなくてそれぞれ一つずつの関数にする
  - 一つずつに分けることで関数名がわかりやすく変更に強いものになる
- 凝集度と結合度
  - 凝集度(ぎょうしゅうど)
    - モジュールの中の話。
    - モジュール内の要素がどれだけ密接に関連しているかを測るための概念。関連しているほど凝集度が高い
    - 凝集度を高くすると責務ごとにクラスを分けるので、責務ごとの接合度が低くなりやすい
  - 結合度
    - モジュール間の話。
    - モジュール間の依存関係の強さを表す概念。
    - あるモジュールが他のモジュールにどれだけ依存しているかを測る指標
    - モジュール間の結合度が低いと変更の影響範囲が小さいので変更しやすい
  - 変更しやすいソフトウェアにするには
    - モジュール内の関連を最大にする => 凝集度を最大化する
    - モジュール間の関連を最小にする => 結合度を最小化する
    - 良質な設計は、高凝集、低結合になる傾向がある
- デメリット
  - クラス1 - メソッド1の考え方だと処理が複雑になり、コード量も増える
  - そこでFaced(ファサード)パターンというデザインパターンを使用する
    - 複雑なオブジェクト操作の手順をまとめて、簡単なインターフェースを提供するパターン
    - 例えばそれぞれクラスで分けた処理を一つのクラスとしてまとめること
    - コンストラクタ作成時にそれぞれのクラスのインスタンスを生成。メソッドでそれぞれを順に呼ぶなど。
- クラスを見出す方法
  - SRPは最もシンプルな原則の一つだが、正しく適用することが最も難しい原則の一つ。
  - 経験を積むしかない。かも
  - ただ、設計やアーキテクチャを学ぶことで、クラスの典型的な責務を知ることが大事
    - 学ぶべきこととして、デザインパターンとDDD
- DDDらへん
  - 組み込み型の問題点
    - strやintは制限がない。Userクラスを考えた時にnameやageは独自のクラスにするべきでもあると言える
    - 組み込み型の性質はユーザー名や年齢の性質と一致はしない(当たり前)
    - もっというと組み込み型が持つルールはドメイン(ビジネス)ルールとほとんど一致しない
  - 値オブジェクト
    - ドメインと一致する専用の値が必要。そのために使うのが値オブジェクト
    - Userクラスを作るのに、UserNameクラスと、Ageクラスを作るみたいな感じ。それをコンストラクタに渡す
    - ユーザー名や年齢のルールを持つオブジェクトを値オブジェクトという
    - 値オブジェクトを使うことによってドメインルールを適用し、不正値を防ぐことができる
    - 値オブジェクトはイミュータブル(不変)であることが求められる

### セクション4 オープン・クローズドの原則
Open Closed Principle OCP 最も重要な原則と言っても過言ではない<br>
クラス、モジュール、関数などのソフトウェアの構成要素は<br>
拡張に対していて開いていて、修正に対して閉じているべき。<br>
言い換えると、既存のコードを変更することなく、機能追加できるべき。

- オープン、クローズドに違反すると
  - ex. notificationに新たにpush通知を追加。sendメソッドにコードを追加
    - 通知方法が増えるために肥大化
    - パターン追加毎に、既存パターンにバグを含ませてしまう可能性を秘めている
  - 実現方法
    - 抽象クラスを使う。例で言うとそれぞれのsend方法でclassを作成。それの大元となる抽象クラスを作る
    - こうすることで、新しい通知方法が増えてもclassを追加するだけでよい
      - 既存のコードに影響を与えない.なのでバグも起こり得ない。肥大化もしない
    - 抽象クラスのメリット
      - 具象クラスに共通のインターフェースを定義することができる
        - どの具象クラスもsendメソッドを持つことを確約する
      - 通知機能のクライアントが、具象クラスに依存しなくなる
        - 抽象クラスを引数で渡すと、サブクラスしか渡せなくなる。具体的な実装はわからなくてもいける。依存していない
  - Strategyパターン
    - アルゴリズムを実行時に選択できるようにするパターン
    - RPAでも使えそう
  - オープン、クローズドの原則のメリデメ
    - メリット
      - 抽象クラスに依存すれば具象クラスが変わってもクライアントの変更は必要ない
      - 具象クラスを追加するだけで機能追加ができる。
      - 変更に強く、影響を最小限にできる
      - 変わりづらいものに依存すれば、変更による影響が小さい
    - デメリット
      - コード量が増える
      - 過度にOCPを適用させてしまう
      - メリットがコストを上回るなら採用するべき
  - Decoratorパターン
    - 既存のコードを変更せずに、オブジェクトに機能を追加することを可能にする
    - まずはアンチパターン
      - コーヒークラスに対して、トッピングがある場合、それぞれのclassを作成する。トッピングごとにclassが増えるのはだるい
      - そしてトッピングが二つとかになるとよりclassが増えるしだるい。
    - アンチパターンに対応できるのがDecoratorパターン
      - トッピングごとのDecoratorを作成し、引数でコーヒー、トッピングしたコーヒーを渡せる
      - 同じ抽象クラスを承継しているサブクラスは、同じように扱える(スイッチできる)
    - まとめ
      - デコレータでラップするだけでトッピングをいくらでも追加できる
      - トッピングの種類が増えたら、デコレータを増やすだけでよい
      - OCPを満たすようにすると自動的にSRPを満たすことにつながる
