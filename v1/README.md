b# Hi👋 こちらはPythonのオブジェクト指向を再度勉強するためのリポジトリです。

特にSOLID原則、デザインパターンなどについて対応します。

下記のUdemyを参照

| フォルダ | リンク |
|:-----------|:------------|
| v1       | [Python で身につける オブジェクト指向【SOLID原則+デザインパターンで、オブジェクト指向設計 の基礎を習得！】](https://www.udemy.com/course/python-solid-design-pattern/)  |


## コースの説明による追記 memo

### セクション1
クリーンアーキテクチャも提唱しているロバート・C・マーティン(Bobおじさん)が提唱<br>
オブジェクト指向開発の5つの原則。<br>
5つの原則を守ることで保守しやすいソフトウェアを設計できる<br>
SOLID原則
- S: 単一責任の原則
- O: オープン、クローズドの原則
- L: リフコフの置換原則
- I: インターフェース分離の原則
- D: 依存関係逆転の原則

SOLID原則を学ぶメリット

そもそもオブジェクト指向の3大要素
- クラス(カプセル化)
- 承継
- ポリモーフィズム

実際は3大要素を学んだだけではオブジェクト指向を最大限活用できない<br>
=> 3大要素は構成要素でしかない(英単語だけを知っていても英作文はできない)<br>
=> SOLID原則を理解して3大要素の効果的な使い方を身につける必要がある


### セクション2
- 例外周り
  - Pythonも0で割ると例外エラーになる
  - キャッチする例外は具体的な方が望ましい
    - 全てをキャッチするExceptionに頼るのではなくて、ValueErrorなど具体的に設定する
  - クラスやメソッドの正しい使用を強制するために
    - オブジェクトを作る際のコンストラクタにて、正常値でないとオブジェクトを作れない使用にしておくとよい。
    - 不正な値が渡されたら例外を発生させるようなメソッドをガード節という
- フールプルーフとアクセス制限
  - foolproofとはバカにも耐えられる設計にすることをいう。
    - ユーザーに頼るのではなく、誤った操作をそもそもできないようにして正しい使用を強制させる設計
    - フールプルーフの考えに基づいてクラス内部からのみアクセス可能なプライベートな属性やメソッドを定義できる
    - ただ、Pythonはクラス内部からのみアクセスできるプライペートな属性を定義できない
      - これはPythonの設計自体がフールプルーフを取り入れているわけではなく、制約より自由に重きを置いているから
      - ただ慣例としてメソッドの先頭に_を取り入れることでプライペートなメソッド、属性を表現できる
    - name mangling(名前マングリング)
      - 先頭にアンスコを2つ入れることで置換する方法(アクセスできなくなるわけではなく置換する)
      - _MyClass__PIのように結果としてアクセスはできてしまう
      - 本当の用途は親クラスと子クラスで変数名が衝突するみたいな時に使う(サブクラスで同じ名前の変数を使いたい場合など)
    - @propertyデコレータ
      - 用途1: 属性を読み取り専用(もどき)にして外部に公開
      - 用途2: 値のアクセス前後に処理を挟む
      - setterを定義することで、プライペートな変数を上書きすることができるようになり、その前後に処理を挟めるようになる
- 依存関係
  - 承継とコンポジション
    - 承継は is aのようになる。クラスの承継など
    - コンポジションは has aのようになる。関数内で持っている的な
    - 依存していると依存先の変更の影響を受けやすい。これは承継もコンポジションも同じ
  - 変更しやすいソフトウェアを作るためには
    - なるべく依存関係は少ない方が望ましい
    - 変更されないもの、変更が少ないものに依存するのが望ましい

### セクション3 単一責任の原則
Single Responsibility Principle：SRP<br>
言い換えると凝集度を高める原則とも言える<br>
値を正常値に保つことも責務と言える、コンストラクタで値のチェックはだめ。値オブジェクトを使ってみたいな

- クラスの変更理由は一つだけにすべきである
  - それぞれのクラスの責務は一つだけにするべき
  - ざっくりいうとクラスには一つのメソッドだけにする。的な。(デメリットもあるよ)
  - VideoControllerクラスという抽象的なクラスではなく、VideoUploader, VideoPlayer, CommentPostみたいに分ける。
    - するとどんなクラスかが分かりやすく、変更に強い。変更する箇所が一つだけになる
- クラスだけではなくてメソッドや関数においても言える
  - データの整形 > 処理 > フォーマット化という複数の責務を持つのではなくてそれぞれ一つずつの関数にする
  - 一つずつに分けることで関数名がわかりやすく変更に強いものになる
- 凝集度と結合度
  - 凝集度(ぎょうしゅうど)
    - モジュールの中の話。
    - モジュール内の要素がどれだけ密接に関連しているかを測るための概念。関連しているほど凝集度が高い
    - 凝集度を高くすると責務ごとにクラスを分けるので、責務ごとの接合度が低くなりやすい
  - 結合度
    - モジュール間の話。
    - モジュール間の依存関係の強さを表す概念。
    - あるモジュールが他のモジュールにどれだけ依存しているかを測る指標
    - モジュール間の結合度が低いと変更の影響範囲が小さいので変更しやすい
  - 変更しやすいソフトウェアにするには
    - モジュール内の関連を最大にする => 凝集度を最大化する
    - モジュール間の関連を最小にする => 結合度を最小化する
    - 良質な設計は、高凝集、低結合になる傾向がある
- デメリット
  - クラス1 - メソッド1の考え方だと処理が複雑になり、コード量も増える
  - そこでFaced(ファサード)パターンというデザインパターンを使用する
    - 複雑なオブジェクト操作の手順をまとめて、簡単なインターフェースを提供するパターン
    - 例えばそれぞれクラスで分けた処理を一つのクラスとしてまとめること
    - コンストラクタ作成時にそれぞれのクラスのインスタンスを生成。メソッドでそれぞれを順に呼ぶなど。
- クラスを見出す方法
  - SRPは最もシンプルな原則の一つだが、正しく適用することが最も難しい原則の一つ。
  - 経験を積むしかない。かも
  - ただ、設計やアーキテクチャを学ぶことで、クラスの典型的な責務を知ることが大事
    - 学ぶべきこととして、デザインパターンとDDD
- DDDらへん
  - 組み込み型の問題点
    - strやintは制限がない。Userクラスを考えた時にnameやageは独自のクラスにするべきでもあると言える
    - 組み込み型の性質はユーザー名や年齢の性質と一致はしない(当たり前)
    - もっというと組み込み型が持つルールはドメイン(ビジネス)ルールとほとんど一致しない
  - 値オブジェクト
    - ドメインと一致する専用の値が必要。そのために使うのが値オブジェクト
    - Userクラスを作るのに、UserNameクラスと、Ageクラスを作るみたいな感じ。それをコンストラクタに渡す
    - ユーザー名や年齢のルールを持つオブジェクトを値オブジェクトという
    - 値オブジェクトを使うことによってドメインルールを適用し、不正値を防ぐことができる
    - 値オブジェクトはイミュータブル(不変)であることが求められる

### セクション4 オープン・クローズドの原則
Open Closed Principle OCP 最も重要な原則と言っても過言ではない<br>
クラス、モジュール、関数などのソフトウェアの構成要素は<br>
拡張に対していて開いていて、修正に対して閉じているべき。<br>
言い換えると、既存のコードを変更することなく、機能追加できるべき。

- オープン、クローズドに違反すると
  - ex. notificationに新たにpush通知を追加。sendメソッドにコードを追加
    - 通知方法が増えるために肥大化
    - パターン追加毎に、既存パターンにバグを含ませてしまう可能性を秘めている
  - 実現方法
    - 抽象クラスを使う。例で言うとそれぞれのsend方法でclassを作成。それの大元となる抽象クラスを作る
    - こうすることで、新しい通知方法が増えてもclassを追加するだけでよい
      - 既存のコードに影響を与えない.なのでバグも起こり得ない。肥大化もしない
    - 抽象クラスのメリット
      - 具象クラスに共通のインターフェースを定義することができる
        - どの具象クラスもsendメソッドを持つことを確約する
      - 通知機能のクライアントが、具象クラスに依存しなくなる
        - 抽象クラスを引数で渡すと、サブクラスしか渡せなくなる。具体的な実装はわからなくてもいける。依存していない
  - Strategyパターン
    - アルゴリズムを実行時に選択できるようにするパターン
    - RPAでも使えそう
  - オープン、クローズドの原則のメリデメ
    - メリット
      - 抽象クラスに依存すれば具象クラスが変わってもクライアントの変更は必要ない
      - 具象クラスを追加するだけで機能追加ができる。
      - 変更に強く、影響を最小限にできる
      - 変わりづらいものに依存すれば、変更による影響が小さい
    - デメリット
      - コード量が増える
      - 過度にOCPを適用させてしまう
      - メリットがコストを上回るなら採用するべき
  - Decoratorパターン
    - 既存のコードを変更せずに、オブジェクトに機能を追加することを可能にする
    - まずはアンチパターン
      - コーヒークラスに対して、トッピングがある場合、それぞれのclassを作成する。トッピングごとにclassが増えるのはだるい
      - そしてトッピングが二つとかになるとよりclassが増えるしだるい。
    - アンチパターンに対応できるのがDecoratorパターン
      - トッピングごとのDecoratorを作成し、引数でコーヒー、トッピングしたコーヒーを渡せる
      - 同じ抽象クラスを承継しているサブクラスは、同じように扱える(スイッチできる)
    - まとめ
      - デコレータでラップするだけでトッピングをいくらでも追加できる
      - トッピングの種類が増えたら、デコレータを増やすだけでよい
      - OCPを満たすようにすると自動的にSRPを満たすことにつながる

### セクション5 リフコフの置換原則
Liskov Substition Principle(LSP)<br>
派生型はその基本型と置換可能でなくてはならない(基本型と派生型どちらも同様に扱える的な)<br>
- 基本型: 親クラス,スーパークラス(のオブジェクト)
- 派生型: 子クラス,サブクラス(のオブジェクト)

- メリット
  - 派生型が基本型と置換可能になるとサブタイプを切り替えられるようになる
    - OCPを実現できる承継が可能になる。(COPを実現するための前提となるような原則)
    - この原則を守るように承継を利用すれば、OCPを守れるようになり変更に強くなる
  - ちょっと話はずれて
    - 承継はとても重要な概念だが、間違った使い方が多くなってしまい、保守性の低下につながった
    - そのため、そもそも承継しないプログラミング言語も誕生(Go, Rust)
- そもそも違反の場合を羅列する
  - ① 派生型で、基本型よりも事前条件を強める
    - subの方で例外が発生する、事前条件を強める場合、置換不可能になる
    - subの方で事前条件を弱める場合、置換可能なので問題なし
  - ② 派生型で、基本型よりも事後条件を弱める
    - 派生型の方が、基本型よりも戻り値の範囲が広くなる -> 置換不可能になる
    - 派生型にて、事後条件を強める場合 -> 置換可能なので問題なし
  - ③ 派生型で、基本型の不変条件に違反する
    - コンストラクタでガード節をしても派生型にて違反したことで置換不可能になる
  - ④ 派生型で、基本型にない例外が発生する（1と同じ）
  - 事前条件、事後条件、普遍条件は「契約による設計」の構成要素
    - 呼び出される機能と、呼び出し側が、英訳を結ぶ(と考える)ことで、ソフトウェアの正確性と頑健性を高める技法
      - 事前条件: 関数の開始時に保証されるべき条件
      - 事後条件: 関数の正常終了時に満たされるべき条件
      - 不変条件: 関数の開始時と正常終了時に共通して保証されるべき状態についての条件。クラス不変表明。
      - => 事前条件が全て満たされている場合、事後条件と不変表明を満足させるものとする必要がある。
  - 演習のメモ
    - 長方形から正方形の関係はis aの関係なので承継できる。がそれよりもクライアントから見てis aの関係かどうかが重要
    - クライアントから見てis aの関係になっているかがLSPを満たすかの基準につながる
  - パラメータオブジェクトパターン
    - 背景
      - 派生型の1つに追加で引数が必要になった。その場合全ての派生型で引数を追加する必要が出てしまう。
    - メリット
      - 複数のパラメータを1つのオブジェクトにまとめることで隠蔽する
      - 引数が新たに必要になってもオブジェクトを変更するだけ(引数自体に影響はない)になる
  - nullオブジェクトパターン
    - 背景
      - 割引が存在しないNoneのケースなどに対応する場合、パラメータオブジェクトではどうする？
      - またNoneでも実装できるが、なるべくNoneはコードから追い出す方が望ましい(バグを引き起こしやすいため)
    - メリット
      - Noneもオブジェクトとして扱う。他の派生型のインターフェースを持つNoneを表現する
      - 直感的にわかりやすく、条件分岐をなくせる

### セクション6 インターフェース分離の原則
Interface Segregation Principle ISP<br>
クライアントに、クライアントが利用しないメソッドへの依存を強制してはならない<br>
ISPはインターフェースに対して、SRPを実施するための原則とも言える

- なぜ違反がダメなのか
  - 不要な依存関係が生まれるので、クラス間の結合度が高まる
  - インターフェース(抽象クラス)が大きくなり、SRP(単一責任)に違反する
  - サブクラスでメソッドを退化させる(事後条件を弱める)ことになりLSP(置換原則)に違反する
    - サブクラスでpassすることにより退化させることにつながる
  - => 結果コードの変更がしづらくなる
  - => 違反することでクライアントが使用しないメソッドが公開してしまう。潜在的なバグを呼びやすい状況につながる。良い設計とはいえない
- どうすればISPを守れるか
  - 巨大化したインターフェースを分割する。以下二つの方法がある
    - 多重承継
      - それぞれでクラスを分割。必要なものだけを複数承継して不要なメソッドを含めないようにする
    - コンポジション
      - それぞれ必要な抽象クラスをコンストラクタで定義してそれぞれのメソッドとして実装する
    - => 使い分けについて
      - 多重継承はわかりやすい。使うものだけ承継しているし可読性が高いかも?
      - コンポジションを使うとstrategyパターンが使える(そこからさらに状況によって使うメソッドが切り替わるみたいな)
  - 必要のないメソッドが公開されていても、使わなければ良いのでは？
    - 以下二つからお勧めできない
      - フールプルーフ
        - バカにも耐える: 使わないものは使えないようにしておくほうが望ましい。
      - Hyrumの法則
        - ユーザーはあらゆる公開された仕様に対して依存するので、使わないメソッドを公開するのは望ましくない
        - 公開しているだけでいつかユーザーは依存する。その可能性を加味して公開しないほうがいい
  - メリットデメリット
    - 太ったインターフェースをシェイプアップして、インターフェースの凝集度を高めるための原則
    - インターフェースが高凝集になり、クライアントと疎結合になる
    - 設計の手間が増えることがデメリットだが、基本的にメリットの方が上回る
  - SRPとの違い
    - SRP: クラスの責務が高凝集になり、責務間が疎結合になる
    - ISP: インターフェースが高凝集になり、クライアントと疎結合になる