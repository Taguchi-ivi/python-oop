# Hi👋 こちらはPythonのオブジェクト指向を再度勉強するためのリポジトリです。

特にSOLID原則、デザインパターンなどについて対応します。

下記のUdemyを参照

| フォルダ | リンク |
|:-----------|:------------|
| v2     | [【脱オブジェクト指向初心者！】Pythonで学ぶSOLID原則・デザインパターン](https://www.udemy.com/course/python-solid-design-patterns/)  |

## コースの説明による追記 memo

### UML
Unified Modeling Languageの略語<br>
日本語では統一モデリング言語<br>
システムの構造や振る舞いを分析したり設計したりする際に、視覚的に表現するための標準化されたモデリング手法<br>
オブジェクト指向開発で用いられることが多い
- メリット
  - 仕様が統一されているため、ルールさえ守れば誰でも作成できる
  - システムの構造をや動作を俯瞰的に捉えることができ、全体像を把握しやすい
  - 世界で共通
- クラス図(一番使われる)
  - システムの構造や関係性を表現するための図
  - 構造を表す
  - 記載内容: クラス名称, 属性1..., メソッド1...
  - 可視性について
    - クラスの属性やメソッドの他のクラスへの公開範囲を表す
    - 可視性の4種類
      - +: public 全クラスからアクセス可能
      - -: private 自クラス内でのみアクセス可能 属性、メソッドの先頭に__(アンスコ2つ)をつける
      - #: protected 自クラス内または承継関係にあるクラスからのみアクセス可能 属性、メソッドの先頭に_(アンスコ1つ)をつける
      - ~: package 同一パッケージ内からのみアクセス可能
  - 承継
    - クラスの共通部分を別クラスにまとめる仕組み
    - 既存のクラスから新しく作ったクラスに機能を引き継ぐことができる. 社員 <- エンジニア, 営業
    - 継承は白矢印の実践で。継承先(子クラス)から継承元(親クラス)へ向く。
  - 抽象クラス(アブストラクトクラス)
    - 引数と戻り値の型のみ定義したメソッドを1つ以上持つクラス
    - 抽象メソッドは斜体で表記
    - 子クラスで必ず実装する必要がある(記載する必要がある)
  - インターフェースと実装
    - pythonではインターフェースは存在しないが、(このコースでは)具体的な実装がない抽象クラスをインターフェースと定義して対応する
    - 具体的な処理を書くのではなく、共通した機能の型のみを定義
    - インターフェースをもとにクラスを作成することを実装(実現)と呼ぶ
    - 実装は白矢印の波線で表す、実装する側からインターフェースへ向く。
  - 集約
    - インスタンスが別のクラスのインスタンスを持っている状態
    - bookShelf(listのBookを持っている) -> Book(categoryを持っている) -> Category
    - 所有する側に白抜きのひし形で表記
  - 関連
    - クラス間の関係性を記述する
    - 矢印とプラスで文字を記載することもできる
  - シーケンス図
    - クラスやオブジェクト間のやり取りを時間軸に沿って表した図
    - 振る舞いを表す
    - client server database など。上から下に向かって時間が進む。
    - apiリクエスト　-> データ読み込み みたいなやつ
    - 認証認可でよく見るやつ
  - UMLを描くための無料ツール
    - [draw.io](https://app.diagrams.net)
    - [PlantUML](https://plantuml.com/ja/) このコースではこれを使う
    - [Mermaid](https://mermaid-js.github.io/mermaid/#/)
  - ※上記記載内容は02_umlフォルダ内の画像見るとわかりやすいかも


### SOLID原則概要
ソフトフェア構築時に従うべきガイドライン<br>
オブジェクト指向プログラミングにおいて、変更しやすく、理解しやすく、再利用しやすいモジュールを設計/開発するためのもの
- S: Single Responsibility Principle 単一責任の原則
- O: Open Closed Principle オープンクローズドの原則
- L: Liskov Substitution Principle リスコフの置換原則
- I: Interface Segregation Principle インターフェース分離の原則
- D: Dependency Inversion Principle 依存性逆転の原則

### 単一責任の原則
クラスはたった一つのアクター(ユーザやステークホルダー)に対して責務を負うべきである<br>
アクターが異なるクラスはアクターごとに分割すべき

- 違反するとどうなる
  - あるアクターのために行った変更が別のアクターにも影響を及ぼす。バグが生まれる可能性がある
  - 変更前にどのアクターに影響があるか調べる工数がかかる
  - 変更後に全てのアクターのテストを実施する工数がかかる
  - 共通部分を同時に変更するなどコンフリクトが起きやすい
- DRYとの関係性
  - DRYにすべきは概念の単位
  - 同じようなロジックであっても、概念が違うものはDRYにするべきではない。
  - ビジネスを理解し、概念を理解していないと単一責任の原則を完全に満たすことは難しい

### オープンクローズドの原則
ソフトウェアの構成要素は拡張に開かれていて、修正に対して閉じていなければならない<br>
拡張に対して開かれている -> 新たなコードを追加することで、機能を拡張することができる<br>
修正に対して閉じている -> 拡張によって既存コードが修正されない<br>
=> ソフトウェアの振る舞いは既存の成果物を変更せずに拡張できるようにするべき

- 違反するとどうなるか
  - 既存のコードに修正を加えると、バグを生んでしまう可能性がある
  - 既存のコードに対して再テストを行う工数がかかる
- 解決策
  - 拡張の可能性のあるものを抽象化し、具体の種別は抽象を実装する
    - インターフェースを介して、抽象クラスに関数を、具象クラスに実際の実装を定義する。

### リスコフの置換原則
継承について。<br>
サブタイプはそのスーパータイプと置換可能でなければならない

- 違反するとどうなる
  - 利用者が想定しない挙動によるバグが発生する可能性が高まる
    - 利用者がサブタイプまで全て理解しないといけなくなる
  - リスコフの置換原則に違反すると、オープンクローズドの原則に違反する可能性が高まる
    - 利用者でクラスを判定するための分岐を入れるのはNG
- 違反している理由について
  - 継承は「is a」の関係
    - 犬は動物である
    - 正方形は長方形である
  - 構文上のエラーは発生しないものの、振る舞いが意図されたものとは異なるため、正しい継承とは言えない
    - 正しい継承 = 「is a」 + 「振る舞いの同等性」
- 契約による設計
  - 事前条件
    - メソッド開始時に保証されるべき条件
    - メソッドの引数、メソッドの開始時のインスタンスの状態
  - 事後条件
    - メソッド正常終了時に保証されるべき条件
    - メソッド正常終了時のインスタンスの状態、クライアントに返す戻り値
  - サブタイプの事前条件はスーパータイプと同じかそれより弱い条件と置き換え、事後条件はスーパータイプと同じかそれより強い条件と置き換える

### インターフェース分離の原則
インターフェースのクライアントにとって利用しないプロパティやメソッドへの依存を強制してはいけない<br>
抽象メソッドは未実装のままではエラーになる<br>
サブクラスに実装を強制できる一方で、関係ないメソッドがあっても実装しないといけない<br>
不必要なプロパティやメソッドにクライアントが依存しなくてもいいように、適切に分割するべき

- 違反するとどうなるか
  - インターフェースに変更があると、実装側で使っていないメソッドである場合も修正しなければならなくなる
  - 不要なメソッドを使わないことでリスコフの置換原則にも違反する
  - インターフェースが複数のアクターに使われる場合、単一責任の原則も違反する

### 依存性逆転の原則
上位のモジュールは下位のモジュールに依存してはならない。どちらもモジュールの抽象に依存すべき<br>
抽象は実装の詳細に依存してはならない。実装の詳細が抽象に依存すべきである<br>
上位モジュールA ->(依存)-> 下位モジュールBの抽象 <-(依存実装)<- 下位モジュールB

- 違反するとどうなるか
  - 下位モジュールの変更が上位モジュールに影響を与える
  - 下位モジュールがないと上位モジュールが開発できない
  - モジュールの拡張性、再利用性が低い
  - 単体テストが困難
- Dependency Injectionとは
  - クラス間の依存関係をソースコードから排除するために、引数などを通じて外部からオブジェクトを渡せるようにするパターン
  - メリデメ
    - メリット
      - クラス間の関連が弱まり、変更に強くなる
      - 実装の詳細がなくても開発を進められる
      - 本番用とテスト用などクラスの切り替えが容易になるのでテストがしやすくなる
    - デメリット
      - 外部から渡すためのインスタンスの生成が大変
      - DIコンテナを用いる場合、別途ライブラリが必要
  - DIコンテナとは
    - 自動でDIを行ってインスタンスを構築してくれる仕組み
    - 有名なライブラリとしてInjectorがある

## デザインパターン
過去のソフトウェア設計者が発見し、蓄積してきた設計のノウハウ集<br>
オブジェクト指向プログラミングにおいて、よく出会う問題とその解決策がまとめられている<br>
一般的にGang of Four(GoF)と呼ばれる4人の開発者によってまとめられた23種類の設計パターンのことを言う。


- デザインパターンの分類
  - 主に3つに分けられる
    - オブジェクト生成に関するパターン
      - Abstract Factory, Builder, Factory Method, Prototype, Singleton
    - プログラムの構造に関するパターン
      - Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy
    - オブジェクトの振る舞いに関するパターン
      - Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor
  - 学ぶ意義
    - よくある問題のベストプラクティスを学べる
    - 再利用性の高い柔軟性
    - 開発者同士の共通言語
    - オブジェクト指向をより深く理解できる
  - 注意点
    - 無理にでも当てはめようとしない。あくまでノウハウ
    - 使い方を間違えると逆に複雑な設計になることもある。

### Template Method
親クラスで処理の枠組みを定め、子クラスで枠組みの具体的な内容を定めるパターン<br>
処理フローがほとんど同じ、その中の異なる部分だけ子クラスで実装する<br>
振る舞いのデザインパターン<br>

template 雛形, 類似したものを簡単に。具体の内容は変更できる

- オブジェクト指向的な要素は
  - 継承を利用したパターン
  - 抽象クラスを継承することで、抽象メソッドの実装を強制することができる
  - 抽象メソッドの実装を変えることで、子クラスごとに異なる処理フローを実現できる
- メリット
  - 共通の処理を親クラスにまとめられる
  - 処理全体の流れは変えず、子クラスごとに一部の処理内容を変えられる
- デメリット
  - 処理全体の流れを親クラスに決められる。拡張性が制限される
  - 子クラスで親クラスのメソッドの振る舞いを変えてしまうとリスコフの置換原則に違反する
- 使い所
  - 全体構造は変えることなく、処理の一部のみを変更したい場合
    - テストなど。
  - 多少の違いはあるが、ほぼ同じ処理

### Singleton
クラスが一つのインスタンスのみを持つことを保証し、このインスタンスへアクセスするためのグローバルな方法を提供するパターン<br>
privateなコンストラクタ、唯一のインスタンスを得るためのstaticメソッド、いつも同じインスタンスを返却する<br>
生成に関するデザインパターン<br>

- オブジェクト指向的な要素は
  - カプセル化(データを内部に隠蔽して、そのアクセス方法を提供すること)を利用したパターン
  - 自分自身のインスタンスを内部に保持して管理
  - 他のクラスからのインスタンスへのアクセス方法も提供。この方法でしか外部からアクセスできない
- メリット
  - 開発者は一度しかインスタンス化してはならないといったことを気にしなくて良い。
  - クラスが一つのインスタンスしか持たないことを保証できる
  - インスタンスが1つなのでメモリ効率が良い
    - 昔のPCだと恩恵が大きいが、現在はそこまで
  - 最初にインスタンス化された、その後は使い回しなので、生成コストがかからない
    - 昔のPCだと恩恵が大きいが、現在はそこまで
- デメリット
  - そもそもアンチパターンと言われることも多い
  - 依存関係が非常にわかりづらい
  - 状態を持つ場合は密結合になる
  - 単体テストの実行が困難
  - マルチスレッドでの扱いが難しい
- 使い所
  - プログラムないのクラスで、全てのクライアントが使用できるインスタンスを必ず1つだけに制約するなど
    - ロギング
    - キャッシュ管理
    - コンフィグ
    - データベース接続ドライバ

### Adapter
あるクラスのインターフェースを、そのクラスを利用する側が求める他のインターフェースへ変換する<br>
インターフェースに互換性のないクラス同士を組み合わせることができる<br>
構造に関するデザインパターン<br>
ex: 日本と海外のコンセントの変換アダプター

- オブジェクト指向的要素
  - 継承、委譲、ポリモーフィズムを利用したパターン
  - 継承によって新しいインターフェースを提供する
  - 委譲を使った実装では、別クラスを用意し、その属性に処理を任せて新しいインターフェースを提供する
- メリット
  - 既存のクラスを修正しないので再テストが不要
  - 変換のためのコードをビジネスロジックと分離できるので単一責任の原則に違反しない
  - インターフェースを介して、アダプタと連携するのでオープンクローズドの原則に違反しない
- デメリット
  - インターフェースやクラスが増えるので小さなシステムなどは別の方法を考える
- 使い所
  - 既存クラスを使用したいが、利用したい側のコードと互換性がない
  - 過去に十分テストされて実績のあるクラスに手を加えず再利用したい
  - ソースコードが手に入らない場合

### Iterator
コレクションの内部構造を利用者に見せずに、その要素に順番にアクセスする方法を提供する(コレクションは配列や辞書など)<br>
ループ処理のインデックスiの役割を抽象化し一般化したもの<br>
振る舞いに関するデザインパターン

- オブジェクト指向的要素
  - カプセル化の逆
    - データと操作を1つにまとめるのがカプセル化
    - IteratorではAggregateの操作を切り出して別のクラスとして定義
    - 別クラスとして切り出すことで、コレクションクラスがシンプルに保たれて、再利用せいやメンテ性を高める
- メリッt
  - 利用者がコレクションの詳細なデータを知る必要がない
  - コレクションの実装と探索のためのアルゴリズムを分離できる
  - 既存のコードに修正を加えることなく、新しい種類のコレクションやイテレータを追加できる
- デメリット
  - 単純なコレクションなら使用しない方がコードがシンプル
    - 少なくとも4つのクラスを必要とするため
- 使い所
  - コレクションが複雑なデータ構図、それを利用者から隠したい場合
  - 探索のための方法を複数持たせたい場合

### Factory Method
親クラスでインスタンスの生成方法を定め、具体的に何をどうやって作るかは子クラスで定めるようなパターン<br>
生成したいオブジェクトのコンストクタを呼び出してインスタンスを生成するのではなく、親クラスに定義された生成用のメソッドを呼び出してインスタンスを生成する<br>
Template Methodの応用<br>
生成に関するパターン

- オブジェクト指向的要素
  - 継承を利用したパターン
    - Template Methodと同様に、処理の枠組みを親クラスで決定し、子クラスごとに具体的な生成方法を実装する
- メリット
  - オープンクローズドの原則に違反することなく新しいクラスを追加できる
  - オブジェクトの利用側とオブジェクトの結びつきを弱くできる
- デメリット
  - 簡単なら不要かも
- 使い所
  - 類似した複数種類のオブジェクトを生成する必要がある
  - オブジェクトの生成ロジックが複雑な場合
  - クラスの種類や生成手順が頻繁に変更される可能性がある場合

### Facade(ファサード)
複雑な内部処理をまとめ、システムの外側に簡素化されたインターフェースを提供する<br>
システムの内側にある各クラスの役割や依存関係を考えて、正しい順番でクラスを利用できるようにする<br>
ちなみにFacadeとはフランス語で「建物の正面」という意味<br>
構造に関するデザインパターン<br>

- オブジェクト指向的要素
  - カプセル化
  - クライアントからは提供されたAPIのみ見える。それ以外は関係ない
  - それぞれのクラスはFacadeのメソッドとも言える
  - 内部の構造、複雑さを隠蔽している
- メリット
  - その他クラスの構成を隠蔽できる
  - その他クラスとクライアントの結びつきを弱くする
- デメリット
  - その他クラスの全てに結合されたゴッドクラスになる可能性もある。
- 使い所
  - 複雑のサブシステムの一部の機能を使用する場合
  - クライアントが内部構造を知らなくてもシンプルなAPIで機能を利用できる


### Prototype
原型となるインスタンスをコピーして新しいインスタンスを生成する<br>
親クラスでインスタンスをコピーするためのメソッドを定義、子クラスで自分自身のコピーを返すよう実装<br>
生成に関するデザインパターン

- 前提知識
  - 浅いコピー
    - 変数に格納された値がそのままコピーされる
    - 参照がコピーされるので、参照もと、参照先どちらを変更してももう片方も変更される
  - 深いコピー
    - 参照を格納した変数では実態がコピーされる
    - どちらかを変更してももう片方に影響を与えない
- オブジェクト指向的要素
  - 継承とポリモーフィズム
- メリット
  - オブジェクトの生成処理を隠蔽できる
  - 構築済みのプロトタイプのクローンを使うことで、初期化コードの重複を削減できる
  - 利用者と具体的なクラスの結合度を弱められる
- デメリット
  - 浅いコピーと深いコピーを理解していないと、想定外のバグを生む
- 使い所
  - クラスからのインスタンス生成が難しい場合
  - インスタンス化のコストがコピーよりも高い場合

### Builder
家を建てるのと同じ<br>
同じ生成手順で異なる材料を使って、異なるオブジェクトを生成する<br>
建築者が利用者に渡された材料を使って、一連の手順に沿って生成する<br>
生成に関するパターン

- オブジェクト指向的要素
  - 継承、ポリモーフィズム、委譲を利用
- メリット
  - 生成されるオブジェクトの生成過程や手段を隠蔽できる
  - 構築用のコードをロジックから分離することができる
- デメリット
  - 過剰な設計になることもある
- 使い所
  - 生成手順が同じで、詳細が異なるオブジェクトを生成する場合
  - 大量のパラメータをコンストラクタに渡してオブジェクトを生成する場合
    - 各工程で必要な値のみ渡す。パラメータを小分けにして渡せる。
    - 可読性の向上とバグの可能性を低減

### Abstract Factory
関連したオブジェクト(部品)のセットを生成するためのインターフェースを提供するパターン<br>
部品の具体的な実装には注目せず、抽象のAPIに注目し、そのAPIだけを使って、部品のセットを組み立てていく<br>
生成に関するデザインパターン

MEMO: 部品(インスタンス)を作成するクラスを作って利便性を上げている。それらがすべて抽象に依存している<br>
工場の切替によって使う関数(関連する部品のセット)を作成できる

- オブジェクト指向的要素
  - ポリモーフィズムを利用
- メリット
  - 具体的なクラスをクライアントから隠蔽する
  - 利用する部品群の整合性を保つ
- デメリット
  - 必要なクラス数が多い、複雑になりがち
- 使い所
  - 関連する部品群を決められた種別ごとに整合性を保って切り替えたい場合
- Abstract FactoryとFactory Methodの違い
  - 生成するインスタンス
    - AF: 複数の部品のセットを生成
    - FM: 一つのインスタンスを作成
  - 抽象化の対象
    - AF: クラス(インターフェース)
    - FM: メソッド

### Strategy
戦略という意味を持つ。<br>
複数のアルゴリズムを別個のクラスとして定義、切り替えができるようにする<br>
親クラスでクライアントにアクセスさせるための共通APIを定義。子クラスで具体的なアルゴリズムを実装<br>
振る舞いに関するデザインパターン

- オブジェクト指向的要素
  - 継承、ポリモーフィズム、移譲を利用
- メリット
  - 実行時にオブジェクト内で使用されるアルゴリズムを交換できる
  - 利用側と分離できる
  - アルゴリズムの追加が容易
- デメリット
  - アルゴリズムの種類が少ないと過剰な設計の可能性も。
- 使い所
  - 方法が複数あり、プログラム実行時に動的に切り替えたい場合。
    - OTAが複数あってその中でrun()を切り替えるなど
  - クラス内にアルゴリズムを切り替えるために多くの条件分がある場合。
- Abstract FactoryとFactory Methodの違い
  - 生成するインスタンス
    - AF: 複数の部品のセットを生成
    - FM: 一つのインスタンスを作成
  - 抽象化の対象
    - AF: クラス(インターフェース)
    - FM: メソッド

### State
複数の状態を別個のクラスとして定義し、状態が変化したときに振る舞いを切り替えられるようにするパターン<br>
親クラスで書く状態が持つべき共通のAPIを定義、子クラス具体的な振る舞いを実装する<br>
振る舞いに関するデザインパターン

- オブジェクト指向的要素
  - 継承、ポリモーフィズム、移譲を利用
- メリット
  - 状態における実装の詳細を別クラスに分離できる
  - 固有の処理を選択するための条件分がなくなる
  - 状態の追加が容易
- デメリット
  - 状態が少ない場合や滅多に変更されない場合などは過度な設計となる
- 使い所
  - 状態に応じて異なる振る舞いをするオブジェクトがあり、その状態数が多い場合
  - 状態の内容が頻繁に変更される場合
  - 状態に固有の処理を実行させるために多くの条件分岐がある場合

### Chain of Responsibility
クライアントからのリクエストを処理するオブジェクトを鎖のように繋げ、処理が可能なオブジェクトにリクエストを順に渡していくパターン<br>
バケツリレーのようなイメージ, 自身で処理する必要があるか判断し、自分で対処できない場合は次へ渡す<br>
振る舞いに関するデザインパターン


- オブジェクト指向的要素
  - ポリモーフィズムを利用
- メリット
  - 処理順を制御できる
  - リクエストの送信側と受信側の結びつきを弱くする
  - 新しい処理クラスを容易に追加できる
- デメリット
  - 処理がたらい回しされるので、パフォーマンスに影響が出る可能性もある
- 使い所
  - 特定の順序で複数の処理を実行する必要がある場合
  - ハンドラの組み合わせと順序を実行時に変更したい場合(setterでnextをセットすることで可能)

### Composite
ツリー構造を持つデータに再起的な処理を行えるようにするパターン(ツリー構造は一つの要素が複数の子要素を持ち枝分かれしていく構造)<br>
任意の枝や末端の葉に対して、共通の手順でアクセスするためのAPIを提供<br>
構造に関するデザインパターン


- オブジェクト指向的要素
  - ポリモーフィズムを利用
- メリット
  - 複雑なツリー構造を簡単に扱える
  - 新しい枝葉を簡単に追加できる
- デメリット
  - 枝と葉の機能が大きく異なる場合は共通のAPIを作るのが困難
- 使い所
  - 再起的なツリー構造を実装する場合


### Decorator
基本となるオブジェクトに対して、柔軟に機能を追加するパターン<br>
継承よりも柔軟で動的に機能追加が可能。オブジェクトを包むように見えることからWrapperパターンとも呼ばれる<br>
構造に関するデザインパターン


- オブジェクト指向的要素
  - 継承、ポリモーフィズムを利用
- メリット
  - 実行時の機能追加が容易
  - 複数の機能を組み合わせることが可能
- デメリット
  - 組み合わせた機能から特定の機能を削除することは困難
  - 振る舞いがデコレーターの組み合わせの順序に依存
- 使い所
  - 追加したい機能のパターンが複数ある、順序がある
  - 継承を使って、オブジェクトの拡張が困難。(Pythonにはないが、finalキーワードがついたクラスなど)


### Proxy
代理となるオブジェクトを通じて、間接的に目的のオブジェクトにアクセスさせるためのパターン<br>
目的のオブジェクトへのアクセスを制限する、リクエストが届く前後処理を挟むなどできる<br>
構造に関するデザインパターン


- オブジェクト指向的要素
  - ポリモーフィズムと委譲を利用したパターン
- メリット
  - オブジェクトへのアクセスが間接的になる
  - 目的のオブジェクトがまだ存在しない場合でも開発を進められる
  - 容易に新規プロキシを追加できる
- デメリット
  - 前後処理などが不要な場合、不要なクラス作成にも繋がる
- 使い所
  - 前後に処理を追加したい場合。ロギングやキャッシュ
  - 目的のオブジェクトに対してアクセスを制御したい場合

