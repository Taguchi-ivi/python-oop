# Hi👋 こちらはPythonのオブジェクト指向を再度勉強するためのリポジトリです。

特にSOLID原則、デザインパターンなどについて対応します。

下記のUdemyを参照

| フォルダ | リンク |
|:-----------|:------------|
| v2     | [【脱オブジェクト指向初心者！】Pythonで学ぶSOLID原則・デザインパターン](https://www.udemy.com/course/python-solid-design-patterns/)  |

## コースの説明による追記 memo

### UML
Unified Modeling Languageの略語<br>
日本語では統一モデリング言語<br>
システムの構造や振る舞いを分析したり設計したりする際に、視覚的に表現するための標準化されたモデリング手法<br>
オブジェクト指向開発で用いられることが多い
- メリット
  - 仕様が統一されているため、ルールさえ守れば誰でも作成できる
  - システムの構造をや動作を俯瞰的に捉えることができ、全体像を把握しやすい
  - 世界で共通
- クラス図(一番使われる)
  - システムの構造や関係性を表現するための図
  - 構造を表す
  - 記載内容: クラス名称, 属性1..., メソッド1...
  - 可視性について
    - クラスの属性やメソッドの他のクラスへの公開範囲を表す
    - 可視性の4種類
      - +: public 全クラスからアクセス可能
      - -: private 自クラス内でのみアクセス可能 属性、メソッドの先頭に__(アンスコ2つ)をつける
      - #: protected 自クラス内または承継関係にあるクラスからのみアクセス可能 属性、メソッドの先頭に_(アンスコ1つ)をつける
      - ~: package 同一パッケージ内からのみアクセス可能
  - 承継
    - クラスの共通部分を別クラスにまとめる仕組み
    - 既存のクラスから新しく作ったクラスに機能を引き継ぐことができる. 社員 <- エンジニア, 営業
    - 継承は白矢印の実践で。継承先(子クラス)から継承元(親クラス)へ向く。
  - 抽象クラス(アブストラクトクラス)
    - 引数と戻り値の型のみ定義したメソッドを1つ以上持つクラス
    - 抽象メソッドは斜体で表記
    - 子クラスで必ず実装する必要がある(記載する必要がある)
  - インターフェースと実装
    - pythonではインターフェースは存在しないが、(このコースでは)具体的な実装がない抽象クラスをインターフェースと定義して対応する
    - 具体的な処理を書くのではなく、共通した機能の型のみを定義
    - インターフェースをもとにクラスを作成することを実装(実現)と呼ぶ
    - 実装は白矢印の波線で表す、実装する側からインターフェースへ向く。
  - 集約
    - インスタンスが別のクラスのインスタンスを持っている状態
    - bookShelf(listのBookを持っている) -> Book(categoryを持っている) -> Category
    - 所有する側に白抜きのひし形で表記
  - 関連
    - クラス間の関係性を記述する
    - 矢印とプラスで文字を記載することもできる
  - シーケンス図
    - クラスやオブジェクト間のやり取りを時間軸に沿って表した図
    - 振る舞いを表す
    - client server database など。上から下に向かって時間が進む。
    - apiリクエスト　-> データ読み込み みたいなやつ
    - 認証認可でよく見るやつ
  - UMLを描くための無料ツール
    - [draw.io](https://app.diagrams.net)
    - [PlantUML](https://plantuml.com/ja/) このコースではこれを使う
    - [Mermaid](https://mermaid-js.github.io/mermaid/#/)
  - ※上記記載内容は02_umlフォルダ内の画像見るとわかりやすいかも


### SOLID原則概要
ソフトフェア構築時に従うべきガイドライン<br>
オブジェクト指向プログラミングにおいて、変更しやすく、理解しやすく、再利用しやすいモジュールを設計/開発するためのもの
- S: Single Responsibility Principle 単一責任の原則
- O: Open Closed Principle オープンクローズドの原則
- L: Liskov Substitution Principle リスコフの置換原則
- I: Interface Segregation Principle インターフェース分離の原則
- D: Dependency Inversion Principle 依存性逆転の原則

### 単一責任の原則
クラスはたった一つのアクター(ユーザやステークホルダー)に対して責務を負うべきである<br>
アクターが異なるクラスはアクターごとに分割すべき

- 違反するとどうなる
  - あるアクターのために行った変更が別のアクターにも影響を及ぼす。バグが生まれる可能性がある
  - 変更前にどのアクターに影響があるか調べる工数がかかる
  - 変更後に全てのアクターのテストを実施する工数がかかる
  - 共通部分を同時に変更するなどコンフリクトが起きやすい
- DRYとの関係性
  - DRYにすべきは概念の単位
  - 同じようなロジックであっても、概念が違うものはDRYにするべきではない。
  - ビジネスを理解し、概念を理解していないと単一責任の原則を完全に満たすことは難しい

### オープンクローズドの原則
ソフトウェアの構成要素は拡張に開かれていて、修正に対して閉じていなければならない<br>
拡張に対して開かれている -> 新たなコードを追加することで、機能を拡張することができる<br>
修正に対して閉じている -> 拡張によって既存コードが修正されない<br>
=> ソフトウェアの振る舞いは既存の成果物を変更せずに拡張できるようにするべき

- 違反するとどうなるか
  - 既存のコードに修正を加えると、バグを生んでしまう可能性がある
  - 既存のコードに対して再テストを行う工数がかかる
- 解決策
  - 拡張の可能性のあるものを抽象化し、具体の種別は抽象を実装する
    - インターフェースを介して、抽象クラスに関数を、具象クラスに実際の実装を定義する。

### リスコフの置換原則
継承について。<br>
サブタイプはそのスーパータイプと置換可能でなければならない

- 違反するとどうなる
  - 利用者が想定しない挙動によるバグが発生する可能性が高まる
    - 利用者がサブタイプまで全て理解しないといけなくなる
  - リスコフの置換原則に違反すると、オープンクローズドの原則に違反する可能性が高まる
    - 利用者でクラスを判定するための分岐を入れるのはNG
- 違反している理由について
  - 継承は「is a」の関係
    - 犬は動物である
    - 正方形は長方形である
  - 構文上のエラーは発生しないものの、振る舞いが意図されたものとは異なるため、正しい継承とは言えない
    - 正しい継承 = 「is a」 + 「振る舞いの同等性」
- 契約による設計
  - 事前条件
    - メソッド開始時に保証されるべき条件
    - メソッドの引数、メソッドの開始時のインスタンスの状態
  - 事後条件
    - メソッド正常終了時に保証されるべき条件
    - メソッド正常終了時のインスタンスの状態、クライアントに返す戻り値
  - サブタイプの事前条件はスーパータイプと同じかそれより弱い条件と置き換え、事後条件はスーパータイプと同じかそれより強い条件と置き換える

### インターフェース分離の原則
インターフェースのクライアントにとって利用しないプロパティやメソッドへの依存を強制してはいけない<br>
抽象メソッドは未実装のままではエラーになる<br>
サブクラスに実装を強制できる一方で、関係ないメソッドがあっても実装しないといけない<br>
不必要なプロパティやメソッドにクライアントが依存しなくてもいいように、適切に分割するべき

- 違反するとどうなるか
  - インターフェースに変更があると、実装側で使っていないメソッドである場合も修正しなければならなくなる
  - 不要なメソッドを使わないことでリスコフの置換原則にも違反する
  - インターフェースが複数のアクターに使われる場合、単一責任の原則も違反する

### 依存性逆転の原則
上位のモジュールは下位のモジュールに依存してはならない。どちらもモジュールの抽象に依存すべき<br>
抽象は実装の詳細に依存してはならない。実装の詳細が抽象に依存すべきである<br>
上位モジュールA ->(依存)-> 下位モジュールBの抽象 <-(依存実装)<- 下位モジュールB

- 違反するとどうなるか
  - 下位モジュールの変更が上位モジュールに影響を与える
  - 下位モジュールがないと上位モジュールが開発できない
  - モジュールの拡張性、再利用性が低い
  - 単体テストが困難
- Dependency Injectionとは
  - クラス間の依存関係をソースコードから排除するために、引数などを通じて外部からオブジェクトを渡せるようにするパターン
  - メリデメ
    - メリット
      - クラス間の関連が弱まり、変更に強くなる
      - 実装の詳細がなくても開発を進められる
      - 本番用とテスト用などクラスの切り替えが容易になるのでテストがしやすくなる
    - デメリット
      - 外部から渡すためのインスタンスの生成が大変
      - DIコンテナを用いる場合、別途ライブラリが必要
  - DIコンテナとは
    - 自動でDIを行ってインスタンスを構築してくれる仕組み
    - 有名なライブラリとしてInjectorがある