# Hi👋 こちらはPythonのオブジェクト指向を再度勉強するためのリポジトリです。

特にSOLID原則、デザインパターンなどについて対応します。

下記のUdemyを参照

| フォルダ | リンク |
|:-----------|:------------|
| v2     | [【脱オブジェクト指向初心者！】Pythonで学ぶSOLID原則・デザインパターン](https://www.udemy.com/course/python-solid-design-patterns/)  |

## コースの説明による追記 memo

### UML
Unified Modeling Languageの略語<br>
日本語では統一モデリング言語<br>
システムの構造や振る舞いを分析したり設計したりする際に、視覚的に表現するための標準化されたモデリング手法<br>
オブジェクト指向開発で用いられることが多い
- メリット
  - 仕様が統一されているため、ルールさえ守れば誰でも作成できる
  - システムの構造をや動作を俯瞰的に捉えることができ、全体像を把握しやすい
  - 世界で共通
- クラス図(一番使われる)
  - システムの構造や関係性を表現するための図
  - 構造を表す
  - 記載内容: クラス名称, 属性1..., メソッド1...
  - 可視性について
    - クラスの属性やメソッドの他のクラスへの公開範囲を表す
    - 可視性の4種類
      - +: public 全クラスからアクセス可能
      - -: private 自クラス内でのみアクセス可能 属性、メソッドの先頭に__(アンスコ2つ)をつける
      - #: protected 自クラス内または承継関係にあるクラスからのみアクセス可能 属性、メソッドの先頭に_(アンスコ1つ)をつける
      - ~: package 同一パッケージ内からのみアクセス可能
  - 承継
    - クラスの共通部分を別クラスにまとめる仕組み
    - 既存のクラスから新しく作ったクラスに機能を引き継ぐことができる. 社員 <- エンジニア, 営業
    - 継承は白矢印の実践で。継承先(子クラス)から継承元(親クラス)へ向く。
  - 抽象クラス(アブストラクトクラス)
    - 引数と戻り値の型のみ定義したメソッドを1つ以上持つクラス
    - 抽象メソッドは斜体で表記
    - 子クラスで必ず実装する必要がある(記載する必要がある)
  - インターフェースと実装
    - pythonではインターフェースは存在しないが、(このコースでは)具体的な実装がない抽象クラスをインターフェースと定義して対応する
    - 具体的な処理を書くのではなく、共通した機能の型のみを定義
    - インターフェースをもとにクラスを作成することを実装(実現)と呼ぶ
    - 実装は白矢印の波線で表す、実装する側からインターフェースへ向く。
  - 集約
    - インスタンスが別のクラスのインスタンスを持っている状態
    - bookShelf(listのBookを持っている) -> Book(categoryを持っている) -> Category
    - 所有する側に白抜きのひし形で表記
  - 関連
    - クラス間の関係性を記述する
    - 矢印とプラスで文字を記載することもできる
  - シーケンス図
    - クラスやオブジェクト間のやり取りを時間軸に沿って表した図
    - 振る舞いを表す
    - client server database など。上から下に向かって時間が進む。
    - apiリクエスト　-> データ読み込み みたいなやつ
    - 認証認可でよく見るやつ
  - UMLを描くための無料ツール
    - [draw.io](https://app.diagrams.net)
    - [PlantUML](https://plantuml.com/ja/) このコースではこれを使う
    - [Mermaid](https://mermaid-js.github.io/mermaid/#/)
  - ※上記記載内容は02_umlフォルダ内の画像見るとわかりやすいかも


### SOLID原則概要
ソフトフェア構築時に従うべきガイドライン<br>
オブジェクト指向プログラミングにおいて、変更しやすく、理解しやすく、再利用しやすいモジュールを設計/開発するためのもの
- S: Single Responsibility Principle 単一責任の原則
- O: Open Closed Principle オープンクローズドの原則
- L: Liskov Substitution Principle リスコフの置換原則
- I: Interface Segregation Principle インターフェース分離の原則
- D: Dependency Inversion Principle 依存性逆転の原則

### 単一責任の原則
クラスはたった一つのアクター(ユーザやステークホルダー)に対して責務を負うべきである<br>
アクターが異なるクラスはアクターごとに分割すべき

- 違反するとどうなる
  - あるアクターのために行った変更が別のアクターにも影響を及ぼす。バグが生まれる可能性がある
  - 変更前にどのアクターに影響があるか調べる工数がかかる
  - 変更後に全てのアクターのテストを実施する工数がかかる
  - 共通部分を同時に変更するなどコンフリクトが起きやすい
- DRYとの関係性
  - DRYにすべきは概念の単位
  - 同じようなロジックであっても、概念が違うものはDRYにするべきではない。
  - ビジネスを理解し、概念を理解していないと単一責任の原則を完全に満たすことは難しい

### オープンクローズドの原則
ソフトウェアの構成要素は拡張に開かれていて、修正に対して閉じていなければならない<br>
拡張に対して開かれている -> 新たなコードを追加することで、機能を拡張することができる<br>
修正に対して閉じている -> 拡張によって既存コードが修正されない<br>
=> ソフトウェアの振る舞いは既存の成果物を変更せずに拡張できるようにするべき

- 違反するとどうなるか
  - 既存のコードに修正を加えると、バグを生んでしまう可能性がある
  - 既存のコードに対して再テストを行う工数がかかる
- 解決策
  - 拡張の可能性のあるものを抽象化し、具体の種別は抽象を実装する
    - インターフェースを介して、抽象クラスに関数を、具象クラスに実際の実装を定義する。

### リスコフの置換原則
継承について。<br>
サブタイプはそのスーパータイプと置換可能でなければならない

- 違反するとどうなる
  - 利用者が想定しない挙動によるバグが発生する可能性が高まる
    - 利用者がサブタイプまで全て理解しないといけなくなる
  - リスコフの置換原則に違反すると、オープンクローズドの原則に違反する可能性が高まる
    - 利用者でクラスを判定するための分岐を入れるのはNG
- 違反している理由について
  - 継承は「is a」の関係
    - 犬は動物である
    - 正方形は長方形である
  - 構文上のエラーは発生しないものの、振る舞いが意図されたものとは異なるため、正しい継承とは言えない
    - 正しい継承 = 「is a」 + 「振る舞いの同等性」
- 契約による設計
  - 事前条件
    - メソッド開始時に保証されるべき条件
    - メソッドの引数、メソッドの開始時のインスタンスの状態
  - 事後条件
    - メソッド正常終了時に保証されるべき条件
    - メソッド正常終了時のインスタンスの状態、クライアントに返す戻り値
  - サブタイプの事前条件はスーパータイプと同じかそれより弱い条件と置き換え、事後条件はスーパータイプと同じかそれより強い条件と置き換える

### インターフェース分離の原則
インターフェースのクライアントにとって利用しないプロパティやメソッドへの依存を強制してはいけない<br>
抽象メソッドは未実装のままではエラーになる<br>
サブクラスに実装を強制できる一方で、関係ないメソッドがあっても実装しないといけない<br>
不必要なプロパティやメソッドにクライアントが依存しなくてもいいように、適切に分割するべき

- 違反するとどうなるか
  - インターフェースに変更があると、実装側で使っていないメソッドである場合も修正しなければならなくなる
  - 不要なメソッドを使わないことでリスコフの置換原則にも違反する
  - インターフェースが複数のアクターに使われる場合、単一責任の原則も違反する

### 依存性逆転の原則
上位のモジュールは下位のモジュールに依存してはならない。どちらもモジュールの抽象に依存すべき<br>
抽象は実装の詳細に依存してはならない。実装の詳細が抽象に依存すべきである<br>
上位モジュールA ->(依存)-> 下位モジュールBの抽象 <-(依存実装)<- 下位モジュールB

- 違反するとどうなるか
  - 下位モジュールの変更が上位モジュールに影響を与える
  - 下位モジュールがないと上位モジュールが開発できない
  - モジュールの拡張性、再利用性が低い
  - 単体テストが困難
- Dependency Injectionとは
  - クラス間の依存関係をソースコードから排除するために、引数などを通じて外部からオブジェクトを渡せるようにするパターン
  - メリデメ
    - メリット
      - クラス間の関連が弱まり、変更に強くなる
      - 実装の詳細がなくても開発を進められる
      - 本番用とテスト用などクラスの切り替えが容易になるのでテストがしやすくなる
    - デメリット
      - 外部から渡すためのインスタンスの生成が大変
      - DIコンテナを用いる場合、別途ライブラリが必要
  - DIコンテナとは
    - 自動でDIを行ってインスタンスを構築してくれる仕組み
    - 有名なライブラリとしてInjectorがある

## デザインパターン
過去のソフトウェア設計者が発見し、蓄積してきた設計のノウハウ集<br>
オブジェクト指向プログラミングにおいて、よく出会う問題とその解決策がまとめられている<br>
一般的にGang of Four(GoF)と呼ばれる4人の開発者によってまとめられた23種類の設計パターンのことを言う。


- デザインパターンの分類
  - 主に3つに分けられる
    - オブジェクト生成に関するパターン
      - Abstract Factory, Builder, Factory Method, Prototype, Singleton
    - プログラムの構造に関するパターン
      - Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy
    - オブジェクトの振る舞いに関するパターン
      - Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor
  - 学ぶ意義
    - よくある問題のベストプラクティスを学べる
    - 再利用性の高い柔軟性
    - 開発者同士の共通言語
    - オブジェクト指向をより深く理解できる
  - 注意点
    - 無理にでも当てはめようとしない。あくまでノウハウ
    - 使い方を間違えると逆に複雑な設計になることもある。

### Template Method
親クラスで処理の枠組みを定め、子クラスで枠組みの具体的な内容を定めるパターン<br>
処理フローがほとんど同じ、その中の異なる部分だけ子クラスで実装する<br>
振る舞いのデザインパターン<br>

template 雛形, 類似したものを簡単に。具体の内容は変更できる

- オブジェクト指向的な要素は
  - 継承を利用したパターン
  - 抽象クラスを継承することで、抽象メソッドの実装を強制することができる
  - 抽象メソッドの実装を変えることで、子クラスごとに異なる処理フローを実現できる
- メリット
  - 共通の処理を親クラスにまとめられる
  - 処理全体の流れは変えず、子クラスごとに一部の処理内容を変えられる
- デメリット
  - 処理全体の流れを親クラスに決められる。拡張性が制限される
  - 子クラスで親クラスのメソッドの振る舞いを変えてしまうとリスコフの置換原則に違反する
- 使い所
  - 全体構造は変えることなく、処理の一部のみを変更したい場合
    - テストなど。
  - 多少の違いはあるが、ほぼ同じ処理

### Singleton
クラスが一つのインスタンスのみを持つことを保証し、このインスタンスへアクセスするためのグローバルな方法を提供するパターン<br>
privateなコンストラクタ、唯一のインスタンスを得るためのstaticメソッド、いつも同じインスタンスを返却する<br>
生成に関するデザインパターン<br>

- オブジェクト指向的な要素は
  - カプセル化(データを内部に隠蔽して、そのアクセス方法を提供すること)を利用したパターン
  - 自分自身のインスタンスを内部に保持して管理
  - 他のクラスからのインスタンスへのアクセス方法も提供。この方法でしか外部からアクセスできない
- メリット
  - 開発者は一度しかインスタンス化してはならないといったことを気にしなくて良い。
  - クラスが一つのインスタンスしか持たないことを保証できる
  - インスタンスが1つなのでメモリ効率が良い
    - 昔のPCだと恩恵が大きいが、現在はそこまで
  - 最初にインスタンス化された、その後は使い回しなので、生成コストがかからない
    - 昔のPCだと恩恵が大きいが、現在はそこまで
- デメリット
  - そもそもアンチパターンと言われることも多い
  - 依存関係が非常にわかりづらい
  - 状態を持つ場合は密結合になる
  - 単体テストの実行が困難
  - マルチスレッドでの扱いが難しい
- 使い所
  - プログラムないのクラスで、全てのクライアントが使用できるインスタンスを必ず1つだけに制約するなど
    - ロギング
    - キャッシュ管理
    - コンフィグ
    - データベース接続ドライバ

### Adapter
あるクラスのインターフェースを、そのクラスを利用する側が求める他のインターフェースへ変換する<br>
インターフェースに互換性のないクラス同士を組み合わせることができる<br>
構造に関するデザインパターン<br>
ex: 日本と海外のコンセントの変換アダプター

- オブジェクト指向的要素
  - 継承、委譲、ポリモーフィズムを利用したパターン
  - 継承によって新しいインターフェースを提供する
  - 委譲を使った実装では、別クラスを用意し、その属性に処理を任せて新しいインターフェースを提供する
- メリット
  - 既存のクラスを修正しないので再テストが不要
  - 変換のためのコードをビジネスロジックと分離できるので単一責任の原則に違反しない
  - インターフェースを介して、アダプタと連携するのでオープンクローズドの原則に違反しない
- デメリット
  - インターフェースやクラスが増えるので小さなシステムなどは別の方法を考える
- 使い所
  - 既存クラスを使用したいが、利用したい側のコードと互換性がない
  - 過去に十分テストされて実績のあるクラスに手を加えず再利用したい
  - ソースコードが手に入らない場合

### Iterator
コレクションの内部構造を利用者に見せずに、その要素に順番にアクセスする方法を提供する(コレクションは配列や辞書など)<br>
ループ処理のインデックスiの役割を抽象化し一般化したもの<br>
振る舞いに関するデザインパターン

- オブジェクト指向的要素
  - カプセル化の逆
    - データと操作を1つにまとめるのがカプセル化
    - IteratorではAggregateの操作を切り出して別のクラスとして定義
    - 別クラスとして切り出すことで、コレクションクラスがシンプルに保たれて、再利用せいやメンテ性を高める
- メリッt
  - 利用者がコレクションの詳細なデータを知る必要がない
  - コレクションの実装と探索のためのアルゴリズムを分離できる
  - 既存のコードに修正を加えることなく、新しい種類のコレクションやイテレータを追加できる
- デメリット
  - 単純なコレクションなら使用しない方がコードがシンプル
    - 少なくとも4つのクラスを必要とするため
- 使い所
  - コレクションが複雑なデータ構図、それを利用者から隠したい場合
  - 探索のための方法を複数持たせたい場合